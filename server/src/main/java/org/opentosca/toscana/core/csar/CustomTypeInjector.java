package org.opentosca.toscana.core.csar;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.opentosca.toscana.core.parse.InvalidCsarException;
import org.opentosca.toscana.core.transformation.logging.Log;

import com.google.common.collect.Lists;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;

/**
 Responsible for injecting missing but required TOSCAna types into a TOSCA yaml service template.
 <p>
 While TOSCAna itself does not need such type definitions, the winery yaml parser (which is used for syntax validation) does.
 */
public class CustomTypeInjector {

    private final static String CUSTOM_TYPE_DEFINITION_ROOT = "/tosca_definitions";
    private final static String NODES = CUSTOM_TYPE_DEFINITION_ROOT + "/node";
    private final static Map<String, InputStream> NODE_TYPE_DEFINITIONS = new HashMap<>();
    private final static String NOTE = "  # autogenerated by toscana";

    private final Logger logger;

    static {
        loadDefinitions("toscana.nodes.JavaApplication", "toscana.nodes.JavaRuntime");
    }

    public CustomTypeInjector(Log log) {
        this.logger = log.getLogger(CustomTypeInjector.class);
    }

    private static void loadDefinitions(String... fileNames) {
        for (String fileName : fileNames) {
            String definitionPath = String.format("%s/%s.yaml", NODES, fileName);
            System.out.println(definitionPath);
            InputStream definitionStream = CustomTypeInjector.class.getResourceAsStream(definitionPath);
            assert (definitionStream != null);
            NODE_TYPE_DEFINITIONS.put(fileName, definitionStream);
        }
    }

    /**
     Injects TOSCAna type definitions into service templates, if necessary
     */
    public void inject(Csar csar) {
        // currently, only node type definition injection is implemented 
        // - minor changes have to be made in order to inject other types
        try {
            File serviceTemplate = csar.getTemplate();
            String templateContent = FileUtils.readFileToString(serviceTemplate);
            List<String> template = Lists.newArrayList(templateContent.split("\n"));

            for (Map.Entry<String, InputStream> definition : NODE_TYPE_DEFINITIONS.entrySet()) {
                if (isRequired(definition.getKey(), templateContent)) {
                    template = inject(template, definition.getValue(), "node_types:");
                }
            }
            FileUtils.writeLines(serviceTemplate, template);
        } catch (InvalidCsarException | IOException e) {
            logger.error("Failed to inject custom types into csar", e);
        }
    }

    private boolean isRequired(String definitionName, String templateContent) {
        String typeName = definitionName;
        String typeAssignment = "type: " + typeName;
        return (templateContent.contains(typeAssignment));
    }

    private List<String> inject(List<String> template, InputStream definition, String location) throws IOException {
        String typeDefinitionString = IOUtils.toString(definition, "UTF-8");
        List<String> definitionContent = Lists.newArrayList(typeDefinitionString.split("\n"));
        definitionContent.add(0, NOTE);
        definitionContent.add("");
        List<String> injectedTemplate = new LinkedList<>();
        boolean injected = false;
        for (String line : template) {
            injectedTemplate.add(line);
            if (line.startsWith(location) && !injected) {
                injectedTemplate.addAll(definitionContent);
                injected = true;
            }
        }
        if (!injected) {
            injectedTemplate.add("");
            injectedTemplate.add(location);
            injectedTemplate.addAll(definitionContent);
        }
        return injectedTemplate;
    }
}
